# Code Splitting

This feature allows us to split our code into various bundles which can then be loaded on demand or in parallel.

It is used to achieve:

- smaller bundles
- control resource load prioritization

If used correctly, can have a major impact on load time.

**There are three general approaches to code splitting available:**

- **Entry Points**
- **Prevent Duplication**
- **Dynamic Imports**

## **Entry Points**

[Checkout](./01-EntryPoints/webpack.config.js)

- **There are some pitfalls to this approach**

  1. **If there are any duplicated modules between entry chunks they will be included in both bundles.**

  - Why is this a problem?

    - In both entry files _index.js & anotherModule.js_ we've included _lodash_ it means both file contains _lodash module_ which makes it heavy in size, impact on load time. As a result :

      - **Waste of space** :: Duplicated code makes our final build larger than necessary.

      - **Longer load time** :: Users downloading duplicate code for every bundle slows down page loading.

      - **Hard to maintain** :: If there are updates, all bundles containing duplicates must be updated.

  2. **It isn't as flexible and can't be used to dynamically split code with the core application logic.**

- We have to understand for which webpack uses the word _module_?
  - In webpack module means **_block of code_ used in different files**

## Prevent Duplication

```js
const path = require("path");
const htmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  mode: "development",
  entry: {
    index: {
      import: "./src/index.js",
      dependOn: "shared",
    },
    another: {
      import: "./src/another.js",
      dependOn: "shared",
    },
    shared: "lodash",
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  optimization: {
    runtimeChunk: "single",
  },
};
```

[Checkout](./02-PreventDuplication/webpack.config.js)

- **The _dependOn_ option allows to share the modules between the chunks**

- **If we're going to use multiple entry points on a single HTML page, _optimization.runtimeChunk:'single'_ is needed too, otherwise we could get into trouble.**

- **This will create a new bundle named _shared.bundle.js_ (also runtime.bundle.js) in which all shared modules are included and every dependent module will use the file or module on runtime.**

_runtimeChunk: 'single'_ :: This extracts the runtime code that Webpack generates for managing module loading into a separate file (e.g., runtime.bundle.js). It handles the shared runtime logic for all chunks, improving caching and avoiding duplication of runtime code.

### What is Runtime Logic?

When webpack bundle our application, it generates extra code that is required to load and manage our modules during runtime. This is known as the Webpack runtime code or runtime logic.

- The logic is necessary for
  - Loading modules dynamically
  - Managing dependencies between modules.
  - Handling things like _require_, _import_ and _export_.

This does not refers to the main code that is in the main module instead it referes to the additional code that Webpack adds to our bundles to make them work correctly.

- This runtime logic is need to Webpack for:
  - Keep track of which module is loaded.
  - Resolve imports/exports between modules.
  - Manage caching for better performance.

---

### **What Actually Happens**

- **`splitChunks` configuration**:

  - This is responsible for extracting **shared dependencies** (like `lodash`) from `index.bundle.js` and `another.bundle.js` into a separate file, such as `shared.bundle.js`.

- **`runtimeChunk: 'single'` configuration**:
  - This extracts **Webpack's runtime code** (not your application code or `lodash`) into its own bundle, like `runtime.bundle.js`.

---

### **Key Points**

1. **Shared dependencies (`lodash`)**:

   - Extracted by the `splitChunks` configuration.
   - Prevents `lodash` from being included in both `index.bundle.js` and `another.bundle.js`.

2. **Runtime code (Webpack-specific code)**:
   - Generated by Webpack to manage module loading, caching, and dependency resolution.
   - Extracted into a **separate runtime file** (e.g., `runtime.bundle.js`) by `runtimeChunk: 'single'`.

---

### **Conclusion**

No, **`splitChunks` does not extract runtime code.** The runtime code is handled by the **`runtimeChunk: 'single'`** configuration.

Instead:

- **`splitChunks`** extracts shared dependencies (like `lodash`).
- **`runtimeChunk: 'single'`** extracts Webpack's runtime code, which would otherwise be duplicated in multiple bundles.

Together, these configurations improve performance by removing duplication and making caching more effective.

### **Additional Tips**

Although using multiple entry points per page is allowed in webpack, it should be avoided when possible in favor of an entry point with multiple imports: _entry: {['./src/index.js', './src/another.js']}_

This result is a better optimization and consistent execution order when using _async_ script tag.

**_Scenario : 01_**

```ts
entry: {
    index: './src/index.js',
    another: './src/another.js'
}
```

This will generate two separate files with the name of :

- _index.bundle.js_
- _another.bundle.js_

```html
<script src="index.bundle.js" async></script>
<script src="another.bundle.js" async></script>
```

**Problem with this approach**

- **Execution order issues:** Since both scripts are async, they may load and execute in a random order.

  - If _index.js_ depends on _another.js_, this can break the app.

- **Wasted optimization:** Webpack doesn’t know that these two scripts are related, so it can’t properly optimize them.

**_Scenario : 02_**

```ts
entry: {
  page: ["./src/index.js", "./src/another.js"];
}
```

This creates one single file _page.bundle.js_ that includes both _index.js_ and _another.js_

**Benefits**

- **Correct execution order:** Webpack ensures index.js loads before another.js (if needed).

- **Better optimization:** Webpack sees the relationship between files and can merge or deduplicate shared code.

- **Simpler setup:** Fewer script tags make managing the app easier.

#### **When to use single entry points**

Always prefer a single entry point with multiple imports unless:

- We want totally separate bundles for different pages or sections of your app.
- There’s a specific need for independent scripts.

By default, using one entry point simplifies our application and gives better performance.

### SplitChunksPlugin

### [With the given configuration file, let’s clarify the behavior:](./02-PreventDuplication/webpack.config.js)

### **What the Configuration Does**

#### 1. **Entry Points**

```javascript
entry: {
    index: {
        import: './src/index.js',
        dependOn: 'shared',
    },
    another: {
        import: './src/another.js',
        dependOn: 'shared'
    },
    shared: 'lodash'
}
```

- **`dependOn: 'shared'`**:
  - Both `index.js` and `another.js` explicitly declare `lodash` as a shared dependency via `dependOn: 'shared'`.
  - This means Webpack will create:
    - `index.bundle.js`: Contains the code specific to `index.js` (excluding `lodash`).
    - `another.bundle.js`: Contains the code specific to `another.js` (excluding `lodash`).
    - `shared.bundle.js`: Contains `lodash`.

#### 2. **`splitChunks`**

```javascript
optimization: {
  splitChunks: {
    chunks: "all";
  }
}
```

- `splitChunks` ensures that shared dependencies (like `lodash` or any other common code) are extracted into a separate chunk **automatically**, even if `dependOn` wasn’t explicitly defined.

- If there are shared dependencies that weren’t declared in `dependOn` but are large enough to meet Webpack’s size threshold, `splitChunks` will handle them.

---

### **Key Statements Explained**

#### **“Duplicate dependency removed from index.bundle.js and another.bundle.js”**

- Since both `index.js` and `another.js` import `lodash` (a common dependency), Webpack ensures it is moved to `shared.bundle.js`, leaving the main bundles (`index.bundle.js` and `another.bundle.js`) free of `lodash`.

In short, it free up all bundles which are using a dependency which size meets the webpack's threshold.

#### **“Remove the dead weight from our main bundle”**

- By moving `lodash` to `shared.bundle.js`, our main bundles become smaller and load faster because they no longer carry the duplicate code for `lodash`.

#### **“Common dependencies are only extracted into a separate chunk if they meet the size thresholds”**

- If a shared dependency (like a library or your code) is too small, Webpack may leave it in the main bundles instead of creating a separate chunk for it. This avoids creating too many tiny chunks, which can hurt performance.

---

### **Does This Extract Runtime Code Too?**

No, this configuration does **not extract runtime code** into a separate file.

If we want to extract Webpack's **runtime code** (used to load and manage modules) into its own file, we need to add:

```javascript
optimization: {
  runtimeChunk: "single";
}
```

Without `runtimeChunk`, the runtime logic will be included in **both `index.bundle.js` and `another.bundle.js`**, which can cause duplication.

---

### **Final Answer**

This configuration ensures that `lodash` (the shared dependency) is extracted into `shared.bundle.js`, but **it does not extract the runtime logic**. Runtime code extraction requires the `runtimeChunk: 'single'` option.

## Dynamic Imports

There are two techniques for dynamic imports in webpack:

1. **_import()_** : A ECMAScript proposal
2. **_require.ensure_** : Webpack-specific approach
