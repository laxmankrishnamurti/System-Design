# Code Splitting

This feature allows us to split our code into various bundles which can then be loaded on demand or in parallel.

It is used to achieve:

- smaller bundles
- control resource load prioritization

If used correctly, can have a major impact on load time.

**There are three general approaches to code splitting available:**

- **Entry Points**
- **Prevent Duplication**
- **Dynamic Imports**

## **Entry Points**

[Checkout](./01-EntryPoints/webpack.config.js)

- **There are some pitfalls to this approach**

  1. **If there are any duplicated modules between entry chunks they will be included in both bundles.**

  - Why is this a problem?

    - In both entry files _index.js & anotherModule.js_ we've included _lodash_ it means both file contains _lodash module_ which makes it heavy in size, impact on load time. As a result :

      - **Waste of space** :: Duplicated code makes our final build larger than necessary.

      - **Longer load time** :: Users downloading duplicate code for every bundle slows down page loading.

      - **Hard to maintain** :: If there are updates, all bundles containing duplicates must be updated.

  2. **It isn't as flexible and can't be used to dynamically split code with the core application logic.**

- We have to understand for which webpack uses the word _module_?
  - In webpack module means **_block of code_ used in different files**

## Prevent Duplication

```js
const path = require("path");
const htmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  mode: "development",
  entry: {
    index: {
      import: "./src/index.js",
      dependOn: "shared",
    },
    another: {
      import: "./src/another.js",
      dependOn: "shared",
    },
    shared: "lodash",
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  optimization: {
    runtimeChunk: "single",
  },
};
```

[Checkout](./02-PreventDuplication/webpack.config.js)

- **The _dependOn_ option allows to share the modules between the chunks**

- **If we're going to use multiple entry points on a single HTML page, _optimization.runtimeChunk:'single'_ is needed too, otherwise we could get into trouble.**

- **This will create a new bundle named _shared.bundle.js_ (also runtime.bundle.js) in which all shared modules are included and every dependent module will use the file or module on runtime.**

_runtimeChunk: 'single'_ :: This extracts the runtime code that Webpack generates for managing module loading into a separate file (e.g., runtime.bundle.js). It handles the shared runtime logic for all chunks, improving caching and avoiding duplication of runtime code.

### What is Runtime Logic?

When webpack bundle our application, it generates extra code that is required to load and manage our modules during runtime. This is known as the Webpack runtime code or runtime logic.

- The logic is necessary for
  - Loading modules dynamically
  - Managing dependencies between modules.
  - Handling things like _require_, _import_ and _export_.

This does not refers to the main code that is in the main module instead it referes to the additional code that Webpack adds to our bundles to make them work correctly.

- This runtime logic is need to Webpack for:
  - Keep track of which module is loaded.
  - Resolve imports/exports between modules.
  - Manage caching for better performance.

---

### **What Actually Happens**

- **`splitChunks` configuration**:

  - This is responsible for extracting **shared dependencies** (like `lodash`) from `index.bundle.js` and `another.bundle.js` into a separate file, such as `shared.bundle.js`.

- **`runtimeChunk: 'single'` configuration**:
  - This extracts **Webpack's runtime code** (not your application code or `lodash`) into its own bundle, like `runtime.bundle.js`.

---

### **Key Points**

1. **Shared dependencies (`lodash`)**:

   - Extracted by the `splitChunks` configuration.
   - Prevents `lodash` from being included in both `index.bundle.js` and `another.bundle.js`.

2. **Runtime code (Webpack-specific code)**:
   - Generated by Webpack to manage module loading, caching, and dependency resolution.
   - Extracted into a **separate runtime file** (e.g., `runtime.bundle.js`) by `runtimeChunk: 'single'`.

---

### **Conclusion**

No, **`splitChunks` does not extract runtime code.** The runtime code is handled by the **`runtimeChunk: 'single'`** configuration.

Instead:

- **`splitChunks`** extracts shared dependencies (like `lodash`).
- **`runtimeChunk: 'single'`** extracts Webpack's runtime code, which would otherwise be duplicated in multiple bundles.

Together, these configurations improve performance by removing duplication and making caching more effective.

### **Additional Tips**

Although using multiple entry points per page is allowed in webpack, it should be avoided when possible in favor of an entry point with multiple imports: _entry: {['./src/index.js', './src/another.js']}_

This result is a better optimization and consistent execution order when using _async_ script tag.

**_Scenario : 01_**

```ts
entry: {
    index: './src/index.js',
    another: './src/another.js'
}
```

This will generate two separate files with the name of :

- _index.bundle.js_
- _another.bundle.js_

```html
<script src="index.bundle.js" async></script>
<script src="another.bundle.js" async></script>
```

**Problem with this approach**

- **Execution order issues:** Since both scripts are async, they may load and execute in a random order.

  - If _index.js_ depends on _another.js_, this can break the app.

- **Wasted optimization:** Webpack doesn’t know that these two scripts are related, so it can’t properly optimize them.

**_Scenario : 02_**

```ts
entry: {
  page: ["./src/index.js", "./src/another.js"];
}
```

This creates one single file _page.bundle.js_ that includes both _index.js_ and _another.js_

**Benefits**

- **Correct execution order:** Webpack ensures index.js loads before another.js (if needed).

- **Better optimization:** Webpack sees the relationship between files and can merge or deduplicate shared code.

- **Simpler setup:** Fewer script tags make managing the app easier.

#### **When to use single entry points**

Always prefer a single entry point with multiple imports unless:

- We want totally separate bundles for different pages or sections of your app.
- There’s a specific need for independent scripts.

By default, using one entry point simplifies our application and gives better performance.

### SplitChunksPlugin

### [With the given configuration file, let’s clarify the behavior:](./02-PreventDuplication/webpack.config.js)

### **What the Configuration Does**

#### 1. **Entry Points**

```javascript
entry: {
    index: {
        import: './src/index.js',
        dependOn: 'shared',
    },
    another: {
        import: './src/another.js',
        dependOn: 'shared'
    },
    shared: 'lodash'
}
```

- **`dependOn: 'shared'`**:
  - Both `index.js` and `another.js` explicitly declare `lodash` as a shared dependency via `dependOn: 'shared'`.
  - This means Webpack will create:
    - `index.bundle.js`: Contains the code specific to `index.js` (excluding `lodash`).
    - `another.bundle.js`: Contains the code specific to `another.js` (excluding `lodash`).
    - `shared.bundle.js`: Contains `lodash`.

#### 2. **`splitChunks`**

```javascript
optimization: {
  splitChunks: {
    chunks: "all";
  }
}
```

- `splitChunks` ensures that shared dependencies (like `lodash` or any other common code) are extracted into a separate chunk **automatically**, even if `dependOn` wasn’t explicitly defined.

- If there are shared dependencies that weren’t declared in `dependOn` but are large enough to meet Webpack’s size threshold, `splitChunks` will handle them.

---

### **Key Statements Explained**

#### **“Duplicate dependency removed from index.bundle.js and another.bundle.js”**

- Since both `index.js` and `another.js` import `lodash` (a common dependency), Webpack ensures it is moved to `shared.bundle.js`, leaving the main bundles (`index.bundle.js` and `another.bundle.js`) free of `lodash`.

In short, it free up all bundles which are using a dependency which size meets the webpack's threshold.

#### **“Remove the dead weight from our main bundle”**

- By moving `lodash` to `shared.bundle.js`, our main bundles become smaller and load faster because they no longer carry the duplicate code for `lodash`.

#### **“Common dependencies are only extracted into a separate chunk if they meet the size thresholds”**

- If a shared dependency (like a library or your code) is too small, Webpack may leave it in the main bundles instead of creating a separate chunk for it. This avoids creating too many tiny chunks, which can hurt performance.

---

### **Does This Extract Runtime Code Too?**

No, this configuration does **not extract runtime code** into a separate file.

If we want to extract Webpack's **runtime code** (used to load and manage modules) into its own file, we need to add:

```javascript
optimization: {
  runtimeChunk: "single";
}
```

Without `runtimeChunk`, the runtime logic will be included in **both `index.bundle.js` and `another.bundle.js`**, which can cause duplication.

---

### **Final Answer**

This configuration ensures that `lodash` (the shared dependency) is extracted into `shared.bundle.js`, but **it does not extract the runtime logic**. Runtime code extraction requires the `runtimeChunk: 'single'` option.

## Dynamic Imports

There are two techniques for dynamic imports in webpack:

1. **_import()_** : A ECMAScript proposal
2. **_require.ensure_** : Webpack-specific approach

### _import()_

- _import(moduleName)_ calls use promises internally

Instead of statically importing _lodash_, we'll use dynamic importing to separate a chunk:

[Checkout](./03-DynamicImports/src/index.js)

- We can also use dynamic expressions to import modules dynamically.
  - import(modulePath)
  - modulePath could potentially be any path to any file in our system or project.

> **"The reason we need `default` is that since webpack 4, when importing a CommonJS module, the import will no longer resolve to the value of `module.exports`. Instead, it will create an artificial namespace object for the CommonJS module."**

1. **Dynamic Imports and Namespaces:**
   When we dynamically import `anotherModule.js` using `import('./anotherModule.js')`, Webpack creates an **ES Module-compatible namespace object** to handle the imported file. This namespace object looks like:

   ```javascript
   {
     default: "webpack", // The default export
     __esModule: true    // Marks it as an ES Module
   }
   ```

2. **`default` and CommonJS Behavior:**

   - If the file being imported is a CommonJS module (using `module.exports`), Webpack will wrap the CommonJS export in a namespace object instead of resolving directly to `module.exports`.
   - In an ES Module, Webpack does the same to ensure compatibility with ES Modules. The `default` export is represented as a property of this namespace object.

### Why `default` Matters

The `default` property is Webpack's way of making imports compatible between CommonJS and ES Modules:

- **For CommonJS Modules:**
  Webpack wraps `module.exports` in a namespace object and assigns it to `default`. Example:

  ```javascript
  // CommonJS
  module.exports = "Hello";

  // When imported via Webpack:
  const imported = await import("./someCommonJSModule");
  console.log(imported.default); // "Hello"
  ```

- **For ES Modules:**
  Webpack generates a namespace object as per ES Module standards. The `default` export is assigned to the `default` property, as seen in your case.

---

**Understand Webpack's Import Behavior**:
Webpack ensures compatibility between CommonJS and ES Modules by wrapping imports in namespace objects. The `default` property plays a crucial role in making these compatible, as the statement describes.

## Prefetching/Preloading modules

- Both are inline directives which is used for _resource hinting_ which tells the browser that for:
  - **prefetch** : resource is probably needed for some navigation in the future
  - **preload** : resource will also be needed during the current navigation

### 1. **prefetch**

An example of this is having a HomePage component, which renders a LoginButton component which then on demand loads a LoginModal component after being clicked.

```js
import(/* webpackPrefetch: true*/ "path/to/the/module.js");
```

Webpack will convert this into this:

```html
<!-- Being appended in the head of the page. -->
<link rel="prefetch" href="model-chunk.bundle.js" />
```

**_Webpack will add the prefetch hint once the parent chunk has been loaded._**

### 2. **preload**

Preload directive has a bunch of differences compared to prefetch:

- A preloaded chunk starts loading in parallel to the parent chunk. A prefetched chunk starts after the parent chunk finishes loading.

- A preloaded chunk has medium priority and is instantly downloaded. A prefetched chunk is downloaded while the browser is idle.

- A preloaded chunk should be instantly requested by the parent chunk. A prefetched chunk can be used anytime in the future.

- Browser support is different.

_Let's imagine a component ChartComponent which needs a huge ChartingLibrary. It displays a LoadingIndicator when rendered and instantly does an on demand import of ChartingLibrary:_

```js
import(/*webpackPreload: true*/ "chartingLibrary");
```

When a page which uses the _ChartComponent_ is requested, the \_charting-library-chunk\_ is also requested via **<link rel="preload">**.

<code>Using webpackPreload incorrectly can actually hurt performance, so be careful when using it</code>

### **Get control over preload**

Sometimes we need to have our own control over preload. For example, preload of any dynamic import can be done via async script. This can be useful in case of streaming server side rendering.

```js
const lazyComp = () =>
  import("DynamicComponent").catch((error) => {
    // Do something with the error.
    // For example, we can retry the request in case of any net error
  });
```

### What if it fails?

- Webpack's runtime code manages the loading of chunks (dynamic modules) at runtime.
- If the script loading (the chunk requested by `import('DynamicComponent')`) fails **before** Webpack's runtime has a chance to manage it (e.g., network issues, the script tag isn't even created yet), the **`catch` handler won't execute immediately.**
- Instead, Webpack waits for a specific timeout (`chunkLoadTimeout`, usually 120 seconds by default) before triggering an error in the `catch` block.

### Why This Happens:

1. **Runtime Code's Role:**
   Webpack’s runtime code dynamically injects `<script>` tags to load chunks. If these fail (e.g., script not found, network failure), the runtime code handles the error after the timeout period.

2. **Failure Before Runtime:**
   If the failure occurs **before** Webpack’s runtime creates the script tag or attempts the actual loading, the runtime has no awareness of the failure until the timeout occurs.

---

In summary:

- Yes, the script Webpack refers to is its runtime code.
- If the failure occurs before Webpack's runtime kicks in to handle module loading, the `catch` block won't execute until the `chunkLoadTimeout` expires.

### Solution :: _To prevent such problem we can add our own onerror handler, which removes the script in case of any error:_

```html
<script
  src="https://example.com/dist/dynamicComponent.js"
  async
  onerror="this.remove()"
></script>
```

In that case, errored script will be removed. Webpack will create its own script(runtime code) and any error will be processed without any timeouts.

## Bundle Analysis

After spilitting the code we must analyze the output to check whether modules have ended up.

[Official analyze tool](https://webpack.github.io/analyse/)

There are some other community-supported options out there as well:

- [webpack-chart](https://alexkuz.github.io/webpack-chart/)
- [webpack-visualizer](https://chrisbateman.github.io/webpack-visualizer/)
- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)
- [webpack-bundle-optimize-helper](https://webpack.jakoblind.no/optimize)
- [bundle-stats](https://github.com/bundle-stats/bundle-stats)
- [webpack-stats-viewer](https://github.com/moonrailgun/webpack-stats-viewer)
